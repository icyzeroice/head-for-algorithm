# 图


# 最小生成树

> Minimum Spanning Tree

```
加权无向图 ---> 最小生成树
    EdgeWeightedGraph 需要 Edge

权重均不相同时 ---> 可以得到唯一的最小生成树

可能有边的权重相同时 ---> 最小生成树可能不唯一
```


### 切分定理

- 横切边


### 最小生成树的贪心算法

每次都应用 *切分定理* 选一条权重最小的边


### Prim 算法

数据结构

- 顶点：marked[]

- 边：
  - 队列 mst 保存最小生成树的边
  - 或者 edgeTo[]

- 横切边：用优先队列比较权重边

维护横切边的集合

- 记得删除失效的边

### Kruskal 算法

将所有边放入优先队列，然后从最小权重边开始，一个个添加入最小生成树的边集合，同事判断有没有形成环，最后生成树。

时间复杂度：E + ElogE （因为一开始排序边需要 ElogE）




# 最短路径

- 边的松弛

- 顶点的松弛

最优性条件：对 `v->w` 边来说，有 `distTo[w] <= distTo[v] + e.weight()`

### Dijkstra 算法

> 权重非负

类似 MST 的 Prim 算法，先生成一个到所有可达点距离都是最小的 MST，然后自然就能得到至某点的最短路径啦。




### 

> 无环加权有向图



### Bellman-Ford 算法

> 可以有环，权可以负值

使用 FIFO
