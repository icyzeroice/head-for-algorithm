#+TITLE: 算法分析 :: 基础
#+AUTHOR: 零度冰华
#+EMAIL: ziv3@outlook.com
#+DATE: 2018/10/30/22:50

* 科学方法

- 关键原则 :: 可重现性


* 观测方法

** 计时器

| Language   | API             |
|------------+-----------------|
| C/C++      |                 |
| Java       | Stopwatch       |
| JavaScript | console.time    |
|            | console.timeEnd |
| Python     |                 |


** 数学模型

*** 任意程序运行时间

1. 执行每条语句的耗时

2. 执行每条语句的频率


*** 步骤

- 输入模型 :: 
- 内循环   :: 
- 成本模型 :: 
- 数学分析 :: 对于给定输入，确定执行频率

*** 举个栗子

**** 二分查找
- 输入模型 :: size 为 N 的数组 =a[]=
- 内循环   :: while 循环中所有语句
- 成本模型 :: 比较操作
- 数学分析 :: 比较次数最多为 =log_2(N) + 1=

增长数量级函数：=log_2(N)=

**** 白名单
- 输入模型 :: 白名单大小 N，标准输入得到的 M 个整数，假设 M>>N
- 内循环   :: while 循环中所有语句
- 成本模型 :: 比较操作（承自二分查找）
- 数学分析 :: 比较次数 =M*(log_2(N)+1)=

增长数量级函数：=M*log_2(N)=


* 增长数量级（倍率定理）

假设 lg 为 log_2

对于 T(N) ~ aN^b * lg(N)

有 T(2N)/T(N) = a(2N)^b * lg(2N) / (aN^b * lgN)
              = 2^b(1 + lg2/lgN)
	      ≈ 2^b


(若 lg 为 log_10，那么结果为 10^b)


| 增长数量级 | 增长数量级函数 |
|------------+----------------|
|          2 | N 或 NlogN     |
|          4 | N^2            |
|          8 | N^3            |
|     2^(9N) | 2^N            |



* 大 O

这种方法很常用，但是在预测算法性能或是比较算法时并没有什么作用。
