# 并查集算法（Union Find）

> 将检测两点连通性的问题，转化为判断两点是否在同一集合内

### 思路步骤：

1. 构造

将区域内每个点视作各不相同的数字，如一共十个点，即可构造一个有 10 个不同数字的数组：

| index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|--|--|--|--|--|--|--|--|--|--|--|
| value | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

> 空间复杂度：O(N)

2. Union 

按题目所给的两点连通条件，将已连通的点以某种方式标记起来。

3. Find

查找目标点在哪个集合中。

### quick-find 算法

- ##### Union

遍历构造出的数组，将相连通的两点的 `value` 标记成同一个值。

> 时间复杂度：O(N)

- ##### Find

直接通过点的 `index` 找出其 `value`。

对需要判断是否在同一个集合中（连通）的两个点都进行此操作，得到它们当前的 `value`，若相等，即连通。


### quick-union 算法

- ##### Union

将相连通的两点中，其中一个的 `value` 赋为另外一个点的 `index`，这样，最后连通集合的结构为树，每棵树根节点的 `index` 等于 `value`。

> 时间复杂度：O(log_2(N))

- ##### Find

通过点的 `value` 找到其相连接的父节点，循环此操作，得到根节点 `value`。

### weighted quick-union 算法（加权 QU）

- ##### Why 加权

因为单纯的 quick-union 算法，在某些情况下，不会生成树，而是生成了链表，那么复杂度就会退化为 O(N)

- ##### Union

在 quick-union 的基础上，每次 Union 时将小树的根节点连接到大树的根节点，即可保证 log_2(N) 的性能


- ##### Find

同 quick-union 算法


### weighted quick-union with path compression 算法（路径压缩的加权 QU）

- ##### Union
同上。

- ##### Find

在 Find 中添加一步，在检查节点的同时，将他们连接到父节点的父节点上去即可。

> 时间复杂度：均摊接近 O(1)，但是最坏情况下也并非常数级别
