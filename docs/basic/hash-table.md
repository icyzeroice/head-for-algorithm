散列表
===

> Hash Table，哈希表，是时间和空间相权衡的经典例子

散列查找算法分两步实行：

1. 将被查找的键转化为数组的一个索引

因为不能达到 _理想状态_（转化得到的索引不会相同），所以还需要：

2. 处理碰撞冲突（拉链法、线性探测法等）



# 散列函数

> 优秀的散列方法：
> 
>   - 一致性
>   - 高效性
>   - 均匀性
> 

### 1. 整数

- 除留余数法

> （用素数当除数，散列值的分布会更好）

### 2. 浮点数

- 乘以 M 然后四舍五入

- 表示为二进制后用除留余数法（Java 的实现）

### 3. 字符串

- 除留余数法

- Horner 方法

### 4. 组合键


# 拉链法

用 M 条链表来保存 N 个键，有冲突就放进同一个链表。


# 线性探测法

> 线性探测法是最简单的开放地址散列表（开放地址散列表：用大小为 M 的数组保存 N 个键值对，M > N， 然后依靠数组中的空位来解决碰撞冲突）。

- 使用一个表保存键，一个表保存值

- 分键簇

- 调整数组大小很重要

- 每次数组长度加倍后，都要重新计算散列值

# 比较

- 拉链法为每个键值对都分配了一小块内存
- 线性探测法用了两个很大的数组

# 应用

- 集合的实现

- 白名单和黑名单

- 字典类
  - 变量名和地址
  - 文件名和文件内容地址
  - DNS 关联 URL 和 IP

- 反向索引

```java
st.put(key, new Queue<String>());
ts.put(val, new Queue<String>());
```

当然还有很多......


# 稀疏向量

> PageRank 算法的核心


参考
===

- 《算法（第4版）》- 3.4 散列表
- 《算法（第4版）》- 3.4 应用